'use client';

import { useEffect, useState } from 'react';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase-client';
import { useAuthStore } from '@/stores/auth-store';
import { AVATARS, FREE_DAILY_LIMIT } from '@/lib/constants';
import { useFullscreen } from '@/hooks/useFullscreen';
import { DashboardHeader } from '@/components/home/DashboardHeader';
import { ModeSelector } from '@/components/home/ModeSelector';
import { GoalPrompt } from '@/components/home/GoalPrompt';
import { TimerDisplay } from '@/components/home/TimerDisplay';
import { ActionButtons } from '@/components/home/ActionButtons';
import { ActiveMatchBanner } from '@/components/home/ActiveMatchBanner';
import { DailyLimitInfo } from '@/components/home/DailyLimitInfo';
import { UtilityButtons } from '@/components/home/UtilityButtons';
import { DashboardBottomNav } from '@/components/layout/DashboardBottomNav';
import { createSoloSession } from '@/lib/session-actions';
import type { User, UserLimit } from '@/types/database';

interface ActiveMatchInfo {
  matchId: string;
  sessionId: string;
  state: string;
}

export default function DashboardPage() {
  const router = useRouter();
  const { user, setUser } = useAuthStore();
  const { isFullscreen, isSupported: isFullscreenSupported, toggle: toggleFullscreen } = useFullscreen();
  const [duration, setDuration] = useState(25);
  const [dailyUsed, setDailyUsed] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isStarting, setIsStarting] = useState(false);
  const [activeMatch, setActiveMatch] = useState<ActiveMatchInfo | null>(null);

  useEffect(() => {
    const supabase = createClient();

    async function load() {
      const { data: { user: authUser } } = await supabase.auth.getUser();
      if (!authUser) {
        router.push('/auth');
        return;
      }

      // User profili
      const { data: profile, error: profileError } = await supabase
        .from('users')
        .select('*')
        .eq('id', authUser.id)
        .maybeSingle();

      if (profileError) {
        console.error('Profil yüklenemedi:', profileError.message);
        if (profileError.code === '42P01' || !profile) {
          const { data: newProfile } = await supabase
            .from('users')
            .upsert({
              id: authUser.id,
              email: authUser.email ?? '',
              name: authUser.email?.split('@')[0] ?? 'Kullanıcı',
              avatar_id: 1,
            })
            .select('*')
            .single();
          if (newProfile) {
            router.push('/onboarding');
            return;
          }
        }
      } else if (profile) {
        const emailPrefix = authUser.email?.split('@')[0] || '';
        const googleName = authUser.user_metadata?.full_name || authUser.user_metadata?.name || '';
        const isAutoGenerated =
          profile.avatar_id === 1 &&
          (profile.name === emailPrefix || profile.name === googleName || profile.name === '');

        if (isAutoGenerated) {
          router.push('/onboarding');
          return;
        }

        setUser(profile as User);
      } else {
        const { data: newProfile } = await supabase
          .from('users')
          .upsert({
            id: authUser.id,
            email: authUser.email ?? '',
            name: authUser.email?.split('@')[0] ?? 'Kullanıcı',
            avatar_id: 1,
          })
          .select('*')
          .single();
        if (newProfile) setUser(newProfile as User);
      }

      // Günlük limit
      const today = new Date().toISOString().split('T')[0];
      const { data: limit } = await supabase
        .from('user_limits')
        .select('sessions_used')
        .eq('user_id', authUser.id)
        .eq('date', today)
        .maybeSingle();

      setDailyUsed((limit as UserLimit | null)?.sessions_used ?? 0);

      // Active match check
      const { data: activeMatchResult } = await supabase.rpc('get_active_match');
      if (activeMatchResult && activeMatchResult.has_active) {
        setActiveMatch({
          matchId: activeMatchResult.match_id,
          sessionId: activeMatchResult.session_id,
          state: activeMatchResult.can_rejoin ? 'broken' : 'active',
        });
      }

      setIsLoading(false);
    }

    load();
  }, [router, setUser]);

  const canStartSession = user?.is_premium || dailyUsed < FREE_DAILY_LIMIT;
  const isRestricted = user ? user.trust_score < 50 : false;
  const avatar = AVATARS.find(a => a.id === user?.avatar_id) ?? AVATARS[0];

  const handleSoloStart = async () => {
    if (!user || !canStartSession || isRestricted || isStarting) return;
    setIsStarting(true);
    const sessionId = await createSoloSession(user.id, duration);
    if (sessionId) {
      router.push(`/session/prepare?id=${sessionId}&solo=true&duration=${duration}`);
    }
    setIsStarting(false);
  };

  const handleMatchStart = () => {
    if (!canStartSession || isRestricted) return;
    router.push(`/session/quick-match?duration=${duration}`);
  };

  const handleRejoin = async () => {
    if (!activeMatch) return;
    if (activeMatch.state === 'active') {
      router.push(`/session/active?id=${activeMatch.sessionId}`);
    } else if (activeMatch.state === 'preparing') {
      router.push(`/session/prepare?id=${activeMatch.sessionId}`);
    } else if (activeMatch.state === 'broken') {
      const supabase = createClient();
      const { data, error } = await supabase.rpc('rejoin_match', {
        p_match_id: activeMatch.matchId,
      });
      if (error || !(data as { success: boolean })?.success) {
        setActiveMatch(null);
        return;
      }
      router.push(`/session/active?id=${activeMatch.sessionId}`);
    }
  };

  const handleDismissMatch = async () => {
    if (!activeMatch) return;
    const supabase = createClient();
    await supabase.rpc('complete_match', { p_match_id: activeMatch.matchId });
    await supabase
      .from('sessions')
      .update({ status: 'abandoned', ended_at: new Date().toISOString() })
      .eq('id', activeMatch.sessionId)
      .in('status', ['waiting', 'preparing', 'active']);
    setActiveMatch(null);
  };

  const handleReset = () => {
    setDuration(25);
  };

  // Loading state
  if (isLoading || !user) {
    return (
      <div className="min-h-screen bg-[#0B0E14] flex items-center justify-center">
        <div className="text-white/40 text-lg">Yükleniyor...</div>
      </div>
    );
  }

  return (
    <div className="relative h-screen overflow-hidden flex flex-col">
      {/* Background Image */}
      <div className="absolute inset-0 z-0">
        <Image
          src="/images/backgrounds/1b651162dfdd425d13f7.jpg"
          alt="Focus background"
          fill
          priority
          className="object-cover"
          sizes="100vw"
          quality={90}
        />
        {/* Apple-style low-opacity overlay */}
        <div
          className="absolute inset-0"
          style={{
            background: 'linear-gradient(rgba(0,0,0,0.25), rgba(0,0,0,0.55))',
          }}
        />
      </div>

      {/* Content */}
      <div className="relative z-10 flex flex-col h-full px-6 pb-24">
        {/* Header */}
        <DashboardHeader avatarEmoji={avatar.emoji} userName={user.name} />

        {/* Active match banner */}
        {activeMatch && (
          <ActiveMatchBanner
            activeMatch={activeMatch}
            onRejoin={handleRejoin}
            onDismiss={handleDismissMatch}
          />
        )}

        {/* Spacer */}
        <div className="flex-1" />

        {/* Mode Selector */}
        <div className="mb-8">
          <ModeSelector selected={duration} onChange={setDuration} />
        </div>

        {/* Goal Prompt */}
        <GoalPrompt />

        {/* Timer Display */}
        <div className="flex items-center justify-center mb-8">
          <TimerDisplay minutes={duration} />
        </div>

        {/* Action Buttons */}
        <ActionButtons
          onSoloStart={handleSoloStart}
          onMatchStart={handleMatchStart}
          canStart={canStartSession}
          isRestricted={isRestricted}
          isStarting={isStarting}
        />

        {/* Daily Limit Info */}
        <DailyLimitInfo
          used={dailyUsed}
          limit={FREE_DAILY_LIMIT}
          isPremium={user.is_premium}
          canStart={canStartSession}
        />

        {/* Utility Buttons */}
        <UtilityButtons onReset={handleReset} />

        {/* Spacer */}
        <div className="flex-1" />
      </div>

      {/* Bottom Nav */}
      <DashboardBottomNav
        streak={user.current_streak}
        dailyUsed={dailyUsed}
        dailyLimit={FREE_DAILY_LIMIT}
        isPremium={user.is_premium}
        isFullscreen={isFullscreen}
        isFullscreenSupported={isFullscreenSupported}
        onToggleFullscreen={toggleFullscreen}
      />
    </div>
  );
}
